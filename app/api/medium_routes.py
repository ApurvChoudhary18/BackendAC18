from fastapi import APIRouter, HTTPException, Body
from fastapi.responses import HTMLResponse
import json
import pandas as pd
from typing import List, Dict, Any

from backend.app.services.medium_services import (
    generate_auth_url,
    exchange_code_for_token,
    fetch_articles_by_username,
    parse_username_from_token_info,
)
from backend.app.pipelines.build_dataset_fast import build_state
from backend.app.services.llm import draft_message_from_state

router = APIRouter()

@router.get("/auth-url")
def auth_url():
    """
    Returns a Medium OAuth authorization URL for frontend to open.
    """
    url = generate_auth_url()
    return {"ok": True, "url": url}

@router.get("/oauth-callback")
def oauth_callback(code: str | None = None, state: str | None = None):
    """
    Exchange code for tokens. This endpoint simply returns HTML showing the token payload
    so the developer can copy it into backend .env or UI.
    """
    if not code:
        raise HTTPException(status_code=400, detail="Missing code")
    try:
        tokens = exchange_code_for_token(code)
        pretty = json.dumps(tokens, indent=2)
        html = "<h3>Medium OAuth tokens (copy into backend/.env MEDIUM_ACCESS_TOKEN / MEDIUM_REFRESH_TOKEN)</h3>"
        html += f"<pre>{pretty}</pre>"
        return HTMLResponse(html)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/fetch")
def fetch_articles(username: str | None = None, limit: int = 10):
    """
    Fetch recent articles using the user's Medium @username via RSS feed.
    Example: /api/medium/fetch?username=yourhandle&limit=5
    """
    if not username:
        raise HTTPException(status_code=400, detail="username required (Medium handle without @)")
    try:
        items = fetch_articles_by_username(username, limit=limit)
        return {"ok": True, "count": len(items), "articles": items}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/draft")
def draft_from_articles(payload: Dict[str, Any] = Body(...)):
    """
    Payload:
    {
      "articles": [ { title, content, published }, ... ],
      "topic": "...", optional
      "max_words": 600 (optional)
    }

    Returns a draft generated by the LLM (using existing draft_message_from_state).
    """
    articles = payload.get("articles") or []
    topic = payload.get("topic") or None
    max_words = int(payload.get("max_words", 600))

    if not articles:
        raise HTTPException(status_code=422, detail="Provide 'articles' array (each item: {title, content, published})")

    rows = []
    for a in articles:
        rows.append({
            "actor": a.get("title") or "author",
            "text": (a.get("content") or a.get("summary") or "")[:10000],
            "timestamp": a.get("published")
        })

    df = pd.DataFrame(rows)
    if "ts" not in df.columns and "timestamp" in df.columns:
        df["ts"] = pd.to_datetime(df["timestamp"], errors="coerce", utc=True)
        df["ts"] = df["ts"].fillna(pd.Timestamp.utcnow())
    if "actor" not in df.columns:
        df["actor"] = "author"
    if "text" not in df.columns:
        df["text"] = ""

    df = df.sort_values("ts").reset_index(drop=True)
    # Build context state from previous articles
    state = build_state(df, N=8)

    try:
        # Use existing LLM wrapper for drafting (platform labelled 'medium')
        draft = draft_message_from_state(
            state=state,
            platform="medium",
            tone=payload.get("tone", "professional"),
            language=payload.get("language", "en"),
            max_words=max_words,
            model=payload.get("model")
        )

        # If user provided a topic, prepend to body or pass via state (simple approach)
        if topic:
            body = f"Topic: {topic}\n\n{draft.get('body','')}"
        else:
            body = draft.get("body", "")

        return {
            "ok": True,
            "state": state,
            "subject": draft.get("subject", ""),
            "body": body,
            "model": draft.get("model", "")
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Draft failed: {e}")
